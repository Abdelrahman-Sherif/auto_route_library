import 'dart:async';
import 'dart:convert';
import 'package:auto_route_generator/auto_route_generator.dart';
import 'package:auto_route_generator/src/models/route_config.dart';
import 'package:auto_route_generator/src/models/router_config.dart';
import 'package:auto_route_generator/utils.dart';
import 'package:build/build.dart';
import 'package:exception_templates/exception_templates.dart';
import 'package:glob/glob.dart';
import 'package:merging_builder_svb/merging_builder_svb.dart';
import 'package:path/path.dart' as path;
import 'package:source_gen/source_gen.dart' show LibraryReader;
import 'package:file/local.dart';
import 'package:auto_route/annotations.dart';
/// Builder that merges its output into one file.
///
/// - Input files must be specified using [Glob] syntax.
///
/// - Requires a generator extending [MergingGenerator].
class AutoRouteMergingBuilder extends SyntheticBuilder<LibDir> {
  /// Constructs a [AutoRouteMergingBuilder] object.
  /// * `inputFiles`: Path to the input files relative to the
  /// package root directory. Glob-style syntax is
  /// allowed, defaults to: `'lib/*.dart'`.
  /// * `outputFile`: defaults to: `'lib/merged_output.dart'`.
  /// * `generator`: Must extend `MergingGenerator<T, A>`.
  /// * `header`: `String` that will be inserted at the top of the
  /// generated file below the 'DO NOT EDIT' warning message.
  /// * `footer`: String that will be inserted at the very bottom of the
  /// generated file.
  /// * `formatter`: A function with signature `String Function(String input)`
  /// that is used to format the generated source code.
  /// The default formatter is: `DartFormatter().format`.
  /// Note: The standard Dart formatter will throw an error if the generated
  /// source code contains invalid syntax. To temporarily suppress formatting
  /// use: `(String input) => input`.
  AutoRouteMergingBuilder({
    String inputFiles = 'lib/**.dart',
    required this.generator,
    String header = '',
    String footer = '',
    this.sortAssets = false,
    String Function(String data)? formatter,
  }) : super(
          inputFiles: inputFiles,
          header: header,
          footer: footer,
          formatter: formatter,
        );

  /// Class extending [MergingGenerator<T,A>].
  final AutoRouteGenerator generator;

  /// Set to true to have assets sorted in reverse topological order of
  /// dependency.
  /// * Defaults to false.
  /// * If a file B includes a file A, then A will be appear
  ///   before B.
  /// * An error is thrown if [sortAssets] is `true` and
  /// a dependency cycle is detected.
  final bool sortAssets;
  late final outputPaths = _outputPaths();

  @override
  Map<String, List<String>> get buildExtensions => {
      syntheticInput.value: outputPaths,
    };

  String get outputFile => 'lib/standalone_(*).dart';

  /// Writes the merged content to the stand-alone file
  /// specified by [outputFile].
  @override
  FutureOr<void> build(BuildStep buildStep) async {
    // Validate synthetic output.
    SyntheticInput.validatePath<LibDir>(inputFiles);

    final libraryAssetIds =
        (sortAssets) ? await orderedLibraryAssetIds(buildStep) : await this.libraryAssetIds(buildStep);

    // Check if output overwrites input.
    for (final libraryAssetId in libraryAssetIds) {
      for(final output in outputPaths) {
        if (path.equals(output, libraryAssetId.path)) {
          throw ErrorOf<AutoRouteMergingBuilder>(
              message: 'Output file clashes with input file!',
              expectedState: 'Output files must not overwrite input files. '
                  'Check the [MergingBuilder] constructor argument [outputFile].',
              invalidState: 'Output: $output is also an input file.');
        }
      }
    }
    final routers = await buildStep.findAssets(Glob("**.gr.json")).toList();
    throwIf(
      routers.isEmpty,
      'Can not find router class, make sure you annotate it with $AutoRouterAnnotation',
    );
    throwIf(
      routers.length > 1,
      'Seems like you have multiple router classes, only one router is supported',
    );

    final routerAsset = routers.first;
    final router = RouterConfig.fromJson(jsonDecode(await buildStep.readAsString(routerAsset)));

    await generator.generateMergedContent(
      _combineStreams(buildStep, libraryAssetIds,router),
      buildStep,
      router,
      routerAsset.changeExtension('.dart'),
    );
  }

  /// Returns a stream of objects of type [T]. Combines the streams
  /// generated by [generator.generateStream]
  /// by iterating over each library file asset.
  Stream<RouteConfig> _combineStreams(
    BuildStep buildStep,
    Iterable<AssetId> libraryAssetIds, RouterConfig router,
  ) async* {
    // Accessing libraries.
    for (final libraryAssetId in libraryAssetIds) {
      final library = LibraryReader(
        await buildStep.resolver.libraryFor(libraryAssetId,allowSyntaxErrors: true),
      );

      // Calling generator.generateStream. An object of type [T] is
      // emitted for each class defined in library that is annotated with [A].
      log.fine('Running ${generator.runtimeType} on: ${libraryAssetId.path}.');
      final streamOfT = generator.generateStream(library, buildStep,router);

      // Combining all objects of type [T] into a stream.
      await for (final RouteConfig t in streamOfT) {
        yield t;
      }
    }
  }

  List<String> _outputPaths() {
   final possibleOutputs =  Glob('**.gr.json').listFileSystemSync(LocalFileSystem());
    final result = <String>[];
    for(final input in possibleOutputs.map((e) => e.path)){
      final output = 'lib/${path.setExtension(input.split('lib').last,'.dart')}';
      SyntheticInput.validatePath<LibDir>(output);
      result.add(output);
      // result.add(output.replaceFirst('.gr', ''));
    }
    return result;
  }
}
